//有n个人围成一圈，顺序排号。从第1个人开始报数，凡是报到3的人退出圈子，问最后留下的人原来排在第几号
//约瑟夫环  算法如下：
//(1)建立一个数组存放所有人的编号（从1开始）
//(2)利用循环结果依次进行报数，直到退出的人数大于或等于当前人数n-1，停止
//(3)在报数过程中如果遇到报数为3，则将该数组元素的编号置为0，并且退出人数+1，同时编号从0重新开始
//   如果遇到编号为0的元素，跳过; 否则继续
//   如果所有人第一轮报数结束，那重新开始报数那重新开始报数
//(4)输出留下元素的编号
#include<stdio.h>
#include <iostream>

using namespace std;
int main()
{
	int i,k,m,n,num[50],*p;
	cout <<"input number of person: n=";
	cin >> n;
	p=num;
	for(i=0;i<n;i++)
		*(p+i)=i+1;
	i=0;
	k=0;
	m=0;
	while(m<n-1)//m是指出局的人数，因为有n个人，最后剩下一个人，所以最多出局（n-1）个人，构成循环
	{
		if(*(p+i)!=0)//判断这个号（原来的序号）是否出局
			k++;//这个号没有出局，就报数，计数器加1
		if(k==3)//报3的出局
		{
			*(p+i)=0;//将出局的这个人标记
			k=0;//使计数器置零，以便后面的人报数
			m++;//出局人数计数器加1
		}
		i++;//将指针后移，虽然i不是指针，但p+i就是指针了，所以i就是为指针服务的
		if(i==n)//如果指针移到了尾部，则返回到头部
			i=0;
	}
//以上的循环是主要焦点，后面的就是找出最后那个人，这个好理解

	while(*p==0)//用这个可以只判断所找号的前面的号（包括所找号），不用判断后面的。
		p++;
	cout << "The last one is N0." << *p <<endl;
	return 0;
}
